# 기본 문제 모음

## 배열 (Array) 문제

### 1. 배열 역순 출력
**난이도**: ⭐  
**문제**: 주어진 배열을 역순으로 출력하는 함수를 작성하세요.  
**입력**: `[1, 2, 3, 4, 5]`  
**출력**: `5 4 3 2 1`  
**힌트**: 반복문을 역순으로 사용하거나 스택을 활용

### 2. 배열에서 최대값 찾기
**난이도**: ⭐  
**문제**: 배열에서 최대값과 최소값을 찾는 함수를 작성하세요.  
**입력**: `[3, 7, 2, 9, 1, 8]`  
**출력**: `최대값: 9, 최소값: 1`  
**힌트**: 한 번의 순회로 최대값과 최소값을 모두 찾을 수 있습니다.

### 3. 배열 회전
**난이도**: ⭐⭐  
**문제**: 배열을 k번 오른쪽으로 회전시키는 함수를 작성하세요.  
**입력**: `[1, 2, 3, 4, 5], k = 2`  
**출력**: `[4, 5, 1, 2, 3]`  
**힌트**: 전체 배열을 뒤집고, 부분적으로 다시 뒤집는 방법

## 연결 리스트 (Linked List) 문제

### 4. 연결 리스트 중간 노드 찾기
**난이도**: ⭐⭐  
**문제**: 연결 리스트의 중간 노드를 찾는 함수를 작성하세요.  
**입력**: `1 -> 2 -> 3 -> 4 -> 5`  
**출력**: `3`  
**힌트**: 빠른 포인터와 느린 포인터를 사용

### 5. 연결 리스트 뒤집기
**난이도**: ⭐⭐  
**문제**: 연결 리스트를 뒤집는 함수를 작성하세요.  
**입력**: `1 -> 2 -> 3 -> 4`  
**출력**: `4 -> 3 -> 2 -> 1`  
**힌트**: 세 개의 포인터를 사용하여 순차적으로 뒤집기

### 6. 연결 리스트에서 중복 제거
**난이도**: ⭐⭐⭐  
**문제**: 정렬된 연결 리스트에서 중복된 노드를 제거하세요.  
**입력**: `1 -> 1 -> 2 -> 3 -> 3`  
**출력**: `1 -> 2 -> 3`  
**힌트**: 인접한 노드들을 비교하여 중복 제거

## 스택 (Stack) 문제

### 7. 괄호 검사
**난이도**: ⭐⭐  
**문제**: 주어진 문자열의 괄호가 올바른지 검사하는 함수를 작성하세요.  
**입력**: `"((()))"`, `"(()"`, `"([)]"`  
**출력**: `true`, `false`, `false`  
**힌트**: 스택을 사용하여 여는 괄호는 push, 닫는 괄호는 pop

### 8. 후위 표기법 계산
**난이도**: ⭐⭐⭐  
**문제**: 후위 표기법으로 된 수식을 계산하는 함수를 작성하세요.  
**입력**: `"3 4 + 2 *"`  
**출력**: `14`  
**힌트**: 숫자는 push, 연산자는 두 개를 pop하여 계산 후 push

## 큐 (Queue) 문제

### 9. 원형 큐 구현
**난이도**: ⭐⭐  
**문제**: 원형 큐를 구현하고 기본 연산들을 작성하세요.  
**연산**: enqueue, dequeue, isEmpty, isFull  
**힌트**: front와 rear 포인터를 사용하여 원형으로 관리

### 10. 큐를 사용한 스택 구현
**난이도**: ⭐⭐⭐  
**문제**: 큐 두 개를 사용하여 스택을 구현하세요.  
**연산**: push, pop, top, empty  
**힌트**: 한 큐는 데이터 저장, 다른 큐는 임시 저장용

## 트리 (Tree) 문제

### 11. 이진 트리 높이 계산
**난이도**: ⭐⭐  
**문제**: 이진 트리의 높이를 계산하는 함수를 작성하세요.  
**입력**: 이진 트리  
**출력**: 트리의 높이  
**힌트**: 재귀적으로 왼쪽과 오른쪽 서브트리의 높이를 비교

### 12. 이진 트리 레벨 순회
**난이도**: ⭐⭐  
**문제**: 이진 트리를 레벨별로 순회하는 함수를 작성하세요.  
**입력**: 이진 트리  
**출력**: 레벨별 노드 값들  
**힌트**: 큐를 사용하여 BFS 방식으로 구현

### 13. 이진 트리 대칭 검사
**난이도**: ⭐⭐⭐  
**문제**: 이진 트리가 대칭인지 검사하는 함수를 작성하세요.  
**입력**: 이진 트리  
**출력**: 대칭 여부 (true/false)  
**힌트**: 왼쪽 서브트리와 오른쪽 서브트리를 비교

## 해시 (Hash) 문제

### 14. 두 수의 합
**난이도**: ⭐⭐  
**문제**: 배열에서 두 수의 합이 target이 되는 인덱스를 찾으세요.  
**입력**: `[2, 7, 11, 15], target = 9`  
**출력**: `[0, 1]`  
**힌트**: 해시 테이블을 사용하여 O(n) 시간에 해결

### 15. 중복 요소 찾기
**난이도**: ⭐⭐  
**문제**: 배열에서 중복된 요소를 찾는 함수를 작성하세요.  
**입력**: `[1, 2, 3, 1]`  
**출력**: `1`  
**힌트**: 해시셋을 사용하여 방문한 요소 추적

## 정렬 (Sorting) 문제

### 16. 버블 정렬 구현
**난이도**: ⭐  
**문제**: 버블 정렬을 구현하세요.  
**입력**: `[64, 34, 25, 12, 22, 11, 90]`  
**출력**: `[11, 12, 22, 25, 34, 64, 90]`  
**힌트**: 인접한 두 요소를 비교하여 교환

### 17. 퀵 정렬 구현
**난이도**: ⭐⭐⭐  
**문제**: 퀵 정렬을 구현하세요.  
**입력**: `[64, 34, 25, 12, 22, 11, 90]`  
**출력**: `[11, 12, 22, 25, 34, 64, 90]`  
**힌트**: 피벗을 선택하고 분할 정복 방식으로 구현

## 문제 풀이 팁

### 📝 문제 분석 단계
1. **입력과 출력 이해**: 문제에서 요구하는 것을 정확히 파악
2. **예시 확인**: 주어진 예시로 알고리즘 검증
3. **경계 조건**: 빈 배열, 한 개 요소, 중복 요소 등 고려
4. **시간/공간 복잡도**: 요구사항에 맞는 효율성 확인

### 🔧 구현 단계
1. **알고리즘 설계**: 단계별로 어떻게 해결할지 계획
2. **코드 작성**: 깔끔하고 읽기 쉬운 코드로 구현
3. **테스트**: 다양한 테스트 케이스로 검증
4. **최적화**: 필요시 성능 개선

### 📊 복잡도 분석
- **시간 복잡도**: 알고리즘이 얼마나 빠른지
- **공간 복잡도**: 메모리를 얼마나 사용하는지
- **최적화**: 더 효율적인 방법이 있는지 고려 