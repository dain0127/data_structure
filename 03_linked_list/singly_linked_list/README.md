# 단일 연결 리스트(Singly Linked List)

## 개념
- 각 노드가 데이터와 다음 노드를 가리키는 포인터를 가지는 선형 자료구조
- 첫 번째 노드를 head라고 하며, 마지막 노드의 포인터는 null
- 동적 메모리 할당으로 크기가 유연하게 조절됨

## 주요 특징
- **메모리**: 각 노드가 별도의 메모리 공간에 저장
- **크기**: 동적 크기 조절 가능
- **접근**: 순차적 접근만 가능 (인덱스 접근 불가)

## 지원하는 연산 (Operations)

### 1. 접근 (Access)
- **조건**: 유효한 인덱스 범위 내
- **시간 복잡도**: O(n)
- **설명**: head부터 순차적으로 이동하여 접근

### 2. 검색 (Search)
- **조건**: 찾고자 하는 요소가 리스트에 존재
- **시간 복잡도**: O(n)
- **설명**: head부터 순차적으로 모든 노드 확인

### 3. 삽입 (Insertion)
- **조건**: 삽입할 위치가 유효
- **시간 복잡도**: O(1) - 위치가 주어진 경우, O(n) - 검색 후 삽입
- **설명**: 포인터만 변경하면 되므로 효율적

### 4. 삭제 (Deletion)
- **조건**: 삭제할 노드가 리스트에 존재
- **시간 복잡도**: O(1) - 위치가 주어진 경우, O(n) - 검색 후 삭제
- **설명**: 포인터만 변경하면 되므로 효율적

### 5. 순회 (Traversal)
- **조건**: 리스트가 비어있지 않음
- **시간 복잡도**: O(n)
- **설명**: 모든 노드를 순차적으로 방문

## 시간 복잡도 요약
| 연산 | 최선 | 평균 | 최악 |
|------|------|------|------|
| 접근 | O(1) | O(n/2) | O(n) |
| 검색 | O(1) | O(n/2) | O(n) |
| 삽입 | O(1) | O(n/2) | O(n) |
| 삭제 | O(1) | O(n/2) | O(n) |

## 공간 복잡도
- **노드당**: O(1) - 데이터 + 포인터
- **전체**: O(n) - 노드 개수만큼

## 실무 활용 사례

### 1. 메모리 관리 시스템
- **용도**: 동적 메모리 할당/해제
- **이유**: 메모리 블록의 효율적 관리

### 2. 파일 시스템
- **용도**: 파일 블록 연결
- **이유**: 파일의 논리적 순서 유지

### 3. 웹 브라우저
- **용도**: 방문 기록 관리
- **이유**: 뒤로가기/앞으로가기 기능

### 4. 음악 플레이어
- **용도**: 재생 목록 관리
- **이유**: 곡의 순서 변경과 삭제

### 5. 게임 개발
- **용도**: 게임 오브젝트 관리
- **이유**: 동적 오브젝트 생성/제거

## 장단점

### 장점
- ✅ 동적 크기 조절
- ✅ 삽입/삭제 효율적 (위치가 주어진 경우)
- ✅ 메모리 효율적 (필요한 만큼만 사용)
- ✅ 구현이 비교적 간단

### 단점
- ❌ 순차 접근만 가능 (랜덤 접근 불가)
- ❌ 포인터 오버헤드
- ❌ 캐시 지역성 떨어짐
- ❌ 역방향 순회 불가

## 구현 파일
- `singly_linked_list.cpp`: 단일 연결 리스트 구현 