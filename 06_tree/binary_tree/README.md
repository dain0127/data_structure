# 이진 트리(Binary Tree)

## 개념
- 각 노드가 최대 2개의 자식 노드를 가지는 트리 자료구조
- 계층적 구조로 데이터를 저장하고 관리
- 루트 노드부터 시작하여 부모-자식 관계로 구성

## 주요 특징
- **구조**: 계층적 구조 (부모-자식 관계)
- **자식 수**: 각 노드당 최대 2개
- **순서**: 일반적으로 순서가 없음 (순서가 있는 경우 특별한 이름 사용)

## 지원하는 연산 (Operations)

### 1. 삽입 (Insertion)
- **조건**: 삽입할 위치가 유효
- **시간 복잡도**: O(h) - h는 트리의 높이
- **설명**: 적절한 위치를 찾아 새 노드 삽입

### 2. 삭제 (Deletion)
- **조건**: 삭제할 노드가 트리에 존재
- **시간 복잡도**: O(h)
- **설명**: 노드 삭제 후 트리 구조 재조정

### 3. 검색 (Search)
- **조건**: 찾고자 하는 요소가 트리에 존재
- **시간 복잡도**: O(h)
- **설명**: 루트부터 시작하여 순회하며 검색

### 4. 순회 (Traversal)
- **조건**: 트리가 비어있지 않음
- **시간 복잡도**: O(n) - n은 노드 개수
- **설명**: 모든 노드를 특정 순서로 방문

## 순회 방법

### 1. 전위 순회 (Preorder)
- **순서**: 루트 → 왼쪽 서브트리 → 오른쪽 서브트리
- **용도**: 트리 구조 복사, 전위 표기법

### 2. 중위 순회 (Inorder)
- **순서**: 왼쪽 서브트리 → 루트 → 오른쪽 서브트리
- **용도**: 정렬된 순서로 데이터 접근

### 3. 후위 순회 (Postorder)
- **순서**: 왼쪽 서브트리 → 오른쪽 서브트리 → 루트
- **용도**: 트리 삭제, 후위 표기법

### 4. 레벨 순회 (Level Order)
- **순서**: 레벨별로 왼쪽부터 오른쪽으로
- **용도**: BFS, 트리 구조 시각화

## 시간 복잡도 요약
| 연산 | 최선 | 평균 | 최악 |
|------|------|------|------|
| 삽입 | O(1) | O(h) | O(n) |
| 삭제 | O(1) | O(h) | O(n) |
| 검색 | O(1) | O(h) | O(n) |
| 순회 | O(n) | O(n) | O(n) |

## 공간 복잡도
- **노드당**: O(1) - 데이터 + 2개 포인터
- **전체**: O(n) - 노드 개수만큼

## 실무 활용 사례

### 1. 파일 시스템
- **용도**: 디렉토리 구조 표현
- **이유**: 폴더와 파일의 계층적 관계

### 2. HTML DOM
- **용도**: 웹 페이지 구조 표현
- **이유**: HTML 요소들의 부모-자식 관계

### 3. XML 문서
- **용도**: XML 노드 구조
- **이유**: 태그의 중첩 구조 표현

### 4. 게임 개발
- **용도**: 게임 오브젝트 계층 구조
- **이유**: 부모-자식 오브젝트 관계

### 5. 조직도
- **용도**: 회사 조직 구조
- **이유**: 상사-부하 관계 표현

### 6. 컴파일러
- **용도**: 구문 분석 트리(AST)
- **이유**: 프로그램 구조 분석

## 장단점

### 장점
- ✅ 계층적 데이터 표현에 적합
- ✅ 검색과 삽입이 효율적 (균형잡힌 경우)
- ✅ 메모리 효율적
- ✅ 다양한 순회 방법

### 단점
- ❌ 균형이 깨지면 성능 저하
- ❌ 구현이 복잡할 수 있음
- ❌ 랜덤 접근 불가

## 구현 파일
- `binary_tree.cpp`: 이진 트리 구현 