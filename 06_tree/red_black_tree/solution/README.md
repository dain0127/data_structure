# 레드-블랙 트리 솔루션

이 디렉토리는 레드-블랙 트리의 완전한 구현을 포함합니다.

## 파일 구조

- `red_black_tree_solution.h`: 헤더 파일
- `red_black_tree_solution.cpp`: 구현 파일
- `README.md`: 이 파일

## 구현된 기능

### 핵심 연산
1. **삽입 (insert)**: 새로운 노드를 레드-블랙 트리에 삽입
2. **삭제 (remove)**: 노드를 레드-블랙 트리에서 삭제
3. **출력 (print)**: 중위 순회로 트리 내용 출력

### 내부 헬퍼 함수
1. **회전 연산**
   - `leftRotate()`: 좌회전
   - `rightRotate()`: 우회전

2. **속성 복원**
   - `insertFixup()`: 삽입 후 레드-블랙 트리 속성 복원
   - `deleteFixup()`: 삭제 후 레드-블랙 트리 속성 복원

3. **유틸리티 함수**
   - `findMin()`, `findMax()`: 최소/최대값 찾기
   - `transplant()`: 노드 교체
   - `inorderHelper()`: 중위 순회 헬퍼

## 레드-블랙 트리 속성

1. **속성 1**: 모든 노드는 빨간색이거나 검은색이다.
2. **속성 2**: 루트는 검은색이다.
3. **속성 3**: 모든 리프(NIL)는 검은색이다.
4. **속성 4**: 빨간 노드의 자식은 모두 검은색이다.
5. **속성 5**: 루트에서 모든 리프까지의 경로에서 검은 노드의 개수는 동일하다.

## 삽입 알고리즘

1. 일반 BST 삽입 수행
2. 새 노드를 빨간색으로 설정
3. `insertFixup()` 호출하여 속성 복원:
   - **케이스 1**: 삼촌이 빨간색 → 색상 변경
   - **케이스 2**: 삼촌이 검은색 (삼각형) → 회전 후 케이스 3
   - **케이스 3**: 삼촌이 검은색 (선형) → 회전 및 색상 변경

## 삭제 알고리즘

1. 일반 BST 삭제 수행
2. 삭제된 노드의 색상 확인
3. 검은색 노드가 삭제된 경우 `deleteFixup()` 호출:
   - **케이스 1**: 형제가 빨간색 → 회전 후 케이스 2, 3, 4
   - **케이스 2**: 형제가 검은색, 형제의 자식들이 모두 검은색 → 색상 변경
   - **케이스 3**: 형제가 검은색, 형제의 한 자식이 빨간색 → 회전 후 케이스 4
   - **케이스 4**: 형제가 검은색, 형제의 다른 자식이 빨간색 → 회전 및 색상 변경

## 컴파일 및 실행

```bash
g++ -o rbt_solution red_black_tree_solution.cpp
./rbt_solution
```

## 테스트 결과 예시

```
=== 레드-블랙 트리 테스트 ===

1. 삽입 연산 테스트:
삽입: 7
중위 순회: 7(B) 
삽입: 3
중위 순회: 3(R) 7(B) 
삽입: 18
중위 순회: 3(R) 7(B) 18(R) 
...

2. 삭제 연산 테스트:
삭제: 18
중위 순회: 2(R) 3(B) 6(R) 7(B) 8(R) 10(B) 11(R) 13(B) 22(R) 26(B) 
...
```

## 시간 복잡도

- **삽입**: O(log n)
- **삭제**: O(log n)
- **검색**: O(log n)

## 공간 복잡도

- **저장 공간**: O(n)
- **재귀 스택**: O(log n) (최악의 경우) 