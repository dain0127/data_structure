# 해시 테이블(Hash Table)

## 개념
- 키-값 쌍을 저장하는 자료구조
- 해시 함수를 사용하여 키를 배열 인덱스로 변환
- 평균적으로 O(1) 시간에 검색, 삽입, 삭제 가능

## 주요 특징
- **구조**: 배열 + 해시 함수
- **접근**: 키를 통한 직접 접근
- **충돌**: 서로 다른 키가 같은 인덱스를 가질 수 있음

## 지원하는 연산 (Operations)

### 1. 삽입 (Insertion)
- **조건**: 키가 유효하고 테이블에 공간이 있어야 함
- **시간 복잡도**: O(1) 평균, O(n) 최악
- **설명**: 키를 해시하여 해당 위치에 값 저장

### 2. 검색 (Search)
- **조건**: 찾고자 하는 키가 테이블에 존재
- **시간 복잡도**: O(1) 평균, O(n) 최악
- **설명**: 키를 해시하여 해당 위치에서 값 검색

### 3. 삭제 (Deletion)
- **조건**: 삭제할 키가 테이블에 존재
- **시간 복잡도**: O(1) 평균, O(n) 최악
- **설명**: 키를 해시하여 해당 위치의 값 삭제

### 4. 업데이트 (Update)
- **조건**: 업데이트할 키가 테이블에 존재
- **시간 복잡도**: O(1) 평균, O(n) 최악
- **설명**: 기존 키의 값을 새로운 값으로 변경

## 충돌 해결 방법

### 1. 체이닝 (Chaining)
- **방법**: 같은 인덱스에 연결 리스트로 저장
- **장점**: 구현이 간단, 삭제가 쉬움
- **단점**: 추가 메모리 필요, 캐시 성능 저하

### 2. 개방 주소법 (Open Addressing)
- **방법**: 충돌 시 다른 빈 위치를 찾아 저장
- **종류**: 선형 탐사, 이차 탐사, 이중 해싱
- **장점**: 메모리 효율적, 캐시 성능 우수
- **단점**: 삭제가 복잡, 클러스터링 문제

## 시간 복잡도 요약
| 연산 | 최선 | 평균 | 최악 |
|------|------|------|------|
| 삽입 | O(1) | O(1) | O(n) |
| 검색 | O(1) | O(1) | O(n) |
| 삭제 | O(1) | O(1) | O(n) |

## 공간 복잡도
- **테이블**: O(n) - 저장된 키-값 쌍 개수
- **추가 공간**: 충돌 해결 방법에 따라 다름

## 실무 활용 사례

### 1. 데이터베이스 인덱싱
- **용도**: 데이터베이스 인덱스 구현
- **이유**: 빠른 키 기반 검색

### 2. 캐싱 시스템
- **용도**: 웹 캐시, CPU 캐시
- **이유**: 빠른 데이터 접근

### 3. 프로그래밍 언어
- **용도**: 딕셔너리, 맵, 연관 배열
- **이유**: 키-값 쌍 저장

### 4. 웹 애플리케이션
- **용도**: 세션 저장, 사용자 정보
- **이유**: 빠른 사용자 식별

### 5. 컴파일러
- **용도**: 심볼 테이블
- **이유**: 변수명과 주소 매핑

### 6. 네트워크 라우팅
- **용도**: IP 주소 테이블
- **이유**: 빠른 패킷 라우팅

### 7. 게임 개발
- **용도**: 게임 오브젝트 관리
- **이유**: 빠른 오브젝트 검색

### 8. 암호화
- **용도**: 해시 함수, 디지털 서명
- **이유**: 데이터 무결성 검증

## 장단점

### 장점
- ✅ 평균적으로 매우 빠른 연산 (O(1))
- ✅ 키-값 쌍 저장에 최적
- ✅ 구현이 비교적 간단
- ✅ 메모리 효율적

### 단점
- ❌ 최악의 경우 성능 저하 (O(n))
- ❌ 순서가 보장되지 않음
- ❌ 해시 함수 설계가 중요
- ❌ 충돌 처리 필요

## 구현 파일
- `hash_table_chaining.cpp`: 체이닝 방식 해시 테이블
- `hash_table_open_addressing.cpp`: 개방 주소법 해시 테이블 